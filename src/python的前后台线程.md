#### python的前后台线程
##### 线程类似于同时执行多个不同程序，多线程运行有如下优点
- 使用线程可以把占据长时间的程序中的任务放到后台取处理
- 程序的运行速度可能很快
- 在一些等待的任务实现上入用户输入，文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们会释放一些珍贵的资源入内存占用等等
- 每个线程都有自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态
- 在其他线程正在运行时，线程可以暂时搁置，这就是线程的退让

##### 在python中启动一个线程，可以使用threading包中的thread建立一个对象，这个thread类的基本原型是：

    t=Thread(target,args=None)
 
 target是要执行的线程函数，args是一个元祖或者列表为target的函数提供参数，然后调用
 t.start()就可以开始线程
 
##### 线程的等待
在多线程的程序中往往一个线程(例如主线程)要等待其他线程执行完毕才继续执行，这可以用join函数。

    线程对象.join()
    
在一个线程代码中执行这条语句，当前的线程就会停止执行，一直等到指定的线程对象执行完毕后才继续执行，
即这条语句启动阻塞等待的作用

#### 多线程与资源
在多个线程的程序中一个普遍存在的问题是，如果多个线程要竞争同时访问与改写公共资源，那么应该怎么样协调各个线程的关系。一个普遍
的使用方法是使用线程锁，python 是由threading.RLock类来创建一个线程锁对象：
     
     lock=threading.Rlock()
     
这个对象lock有两个重要的方法是acquire()与release()

当执行:
      
      lock.acquire()
时强迫lock获取线程锁，如果已经有另外的线程先调用了acquire()方法获取了线程锁而还没有
调用release()释放锁，那么这个lock.acquire()就阻塞当前线程，一直等待锁的控制权，
直到别的线程释放锁后lock.acquire()就获取锁并解除阻塞，线程继续执行

执行后要调用
       
       lock.release()
       
 释放锁，不然别的线程会一直得不到锁的控制权
 
 使用acquire/release的工作机制我们可以把一段修改公共资源的代码用acquire（）和release()夹起来，
 这样就可以保证一次最多只有一个线程在修改
 
      
    